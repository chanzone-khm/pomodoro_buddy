import { DayPlan, PomodoroSlot, Task, TaskStatus } from '../types';
import { assignTaskToSlot, getAllTasks, getTodayDayPlan, removeTaskFromSlot } from '../utils/storage';

export class PomodoroSlots {
  private container: HTMLElement;
  private dayPlan: DayPlan | null = null;
  private tasks: Task[] = [];
  private onSlotUpdate?: () => void;
  private isProcessing: boolean = false;

  // „Ç§„Éô„É≥„Éà„Éè„É≥„Éâ„É©„Éº„Çí„É°„É≥„ÉêÂ§âÊï∞„Å®„Åó„Å¶‰øùÂ≠ò
  private boundHandleDragOver: (event: DragEvent) => void;
  private boundHandleClick: (event: Event) => Promise<void>;
  private boundHandleSlotDragStart: (event: DragEvent) => void;
  private boundHandleSlotDrop: (event: DragEvent) => Promise<void>;

  constructor(container: HTMLElement, onSlotUpdate?: () => void) {
    this.container = container;
    this.onSlotUpdate = onSlotUpdate;

    // „Ç§„Éô„É≥„Éà„Éè„É≥„Éâ„É©„Éº„Çí„Éê„Ç§„É≥„Éâ
    this.boundHandleDragOver = this.handleDragOver.bind(this);
    this.boundHandleClick = this.handleClick.bind(this);
    this.boundHandleSlotDragStart = this.handleSlotDragStart.bind(this);
    this.boundHandleSlotDrop = this.handleSlotDrop.bind(this);

    this.init();
  }

  private async init() {
    await this.loadData();
    this.render();
  }

  private async loadData() {
    this.dayPlan = await getTodayDayPlan();
    this.tasks = await getAllTasks();
  }

  private render() {
    if (!this.dayPlan) return;

    const usedSlots = this.dayPlan.slots.filter(slot => slot.taskId).length;
    const totalSlots = this.dayPlan.slots.length;

    this.container.innerHTML = `
      <div class="pomodoro-slots">
        <div class="slots-header">
          <h3 class="slots-title">‰ªäÊó•„ÅÆüçÖ„Éó„É©„É≥</h3>
          <div class="slots-counter">
            <span class="used-count">${usedSlots}</span>
            <span class="separator">/</span>
            <span class="total-count">${totalSlots}</span>
          </div>
        </div>
        <div class="slots-grid">
          ${this.dayPlan.slots.map(slot => this.renderSlot(slot)).join('')}
        </div>
      </div>
    `;

    this.attachEventListeners();
  }

  private renderSlot(slot: PomodoroSlot): string {
    const task = slot.taskId ? this.tasks.find(t => t.id === slot.taskId) : null;
    const isEmpty = !slot.taskId;
    const isCompleted = slot.completed;

    let slotClass = 'slot';
    if (isEmpty) {
      slotClass += ' slot-empty';
    } else if (isCompleted) {
      slotClass += ' slot-completed';
    } else {
      slotClass += ' slot-assigned';
    }

    return `
      <div class="${slotClass}"
           data-slot-id="${slot.id}"
           data-droppable="true"
           ${!isEmpty ? `draggable="true" data-task-id="${task!.id}"` : ''}
           ${isEmpty ? 'title="„Çø„Çπ„ÇØ„Çí„Éâ„É©„ÉÉ„Ç∞&„Éâ„É≠„ÉÉ„Éó„Åô„Çã„Åã„ÄÅ„ÇØ„É™„ÉÉ„ÇØ„Åó„Å¶ÈÅ∏Êäû"' : 'title="„Éâ„É©„ÉÉ„Ç∞„Åß‰∏¶„Å≥Êõø„Åà"'}>
        ${isEmpty ? this.renderEmptySlot() : this.renderAssignedSlot(task!, slot)}
      </div>
    `;
  }

  private renderEmptySlot(): string {
    return `
      <div class="slot-content slot-empty-content">
        <div class="empty-icon">
          <svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"/>
          </svg>
        </div>
      </div>
    `;
  }

  private renderAssignedSlot(task: Task, slot: PomodoroSlot): string {
    const completionIcon = slot.completed
      ? `<div class="completion-icon">‚úì</div>`
      : `<div class="progress-icon">üçÖ</div>`;

    // „Åì„ÅÆ„Çø„Çπ„ÇØ„ÅÆÂÖ®„Çπ„É≠„ÉÉ„Éà„ÇíÂèñÂæó
    const taskSlots = this.dayPlan?.slots.filter(s => s.taskId === task.id) || [];
    // ÁèæÂú®„ÅÆ„Çπ„É≠„ÉÉ„Éà„Åå‰ΩïÁï™ÁõÆ„Åã„ÇíË®àÁÆó
    const currentSlotIndex = taskSlots.findIndex(s => s.id === slot.id) + 1;
    const totalSlots = taskSlots.length;

    // „Éù„É¢„Éâ„Éº„É≠ÈÄ≤ÊçóË°®Á§∫„Çí„ÄåÁèæÂú®/Á∑èÊï∞„ÄçÂΩ¢Âºè„Å´
    const pomodoroProgress = `${currentSlotIndex}/${totalSlots}`;

    return `
      <div class="slot-content slot-assigned-content">
        ${completionIcon}
        <div class="task-info">
          <div class="task-name" title="${task.name}">${this.truncateText(task.name, 12)}</div>
          <div class="task-progress">${pomodoroProgress}</div>
        </div>
        <div class="slot-actions">
          ${!slot.completed ? `
            <button class="slot-complete-btn" data-slot-id="${slot.id}" title="ÂÆå‰∫Ü">
              <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M5 13l4 4L19 7"/>
              </svg>
            </button>
          ` : ''}
          <button class="slot-remove-btn" data-slot-id="${slot.id}" title="„Çø„Çπ„ÇØ„ÇíÂâäÈô§">
            <svg width="14" height="14" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
            </svg>
          </button>
        </div>
      </div>
    `;
  }

  private truncateText(text: string, maxLength: number): string {
    return text.length > maxLength ? text.substring(0, maxLength) + '...' : text;
  }

  private attachEventListeners() {
    // Êó¢Â≠ò„ÅÆ„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº„ÇíÂâäÈô§ÔºàÈáçË§á„ÇíÈò≤„Åê„Åü„ÇÅÔºâ
    this.container.removeEventListener('dragstart', this.boundHandleSlotDragStart);
    this.container.removeEventListener('dragover', this.boundHandleDragOver);
    this.container.removeEventListener('drop', this.boundHandleSlotDrop);
    this.container.removeEventListener('click', this.boundHandleClick);

    // Êñ∞„Åó„ÅÑ„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº„ÇíËøΩÂä†
    // „Éâ„É©„ÉÉ„Ç∞&„Éâ„É≠„ÉÉ„Éó„Ç§„Éô„É≥„Éà
    this.container.addEventListener('dragstart', this.boundHandleSlotDragStart);
    this.container.addEventListener('dragover', this.boundHandleDragOver);
    this.container.addEventListener('drop', this.boundHandleSlotDrop);

    // „ÇØ„É™„ÉÉ„ÇØ„Ç§„Éô„É≥„Éà
    this.container.addEventListener('click', this.boundHandleClick);
  }

  private handleDragOver(event: DragEvent) {
    event.preventDefault();
    if (event.dataTransfer) {
      event.dataTransfer.dropEffect = 'move';
    }

    // ÁèæÂú®„ÅÆ„Éè„Ç§„É©„Ç§„Éà„Çí„ÇØ„É™„Ç¢
    this.container.querySelectorAll('.slot-dragover').forEach(el => {
      el.classList.remove('slot-dragover');
    });

    // „Éâ„É≠„ÉÉ„ÉóÂèØËÉΩ„Å™„Çπ„É≠„ÉÉ„Éà„Çí„Éè„Ç§„É©„Ç§„Éà
    const slot = (event.target as HTMLElement).closest('.slot[data-droppable="true"]');
    if (slot) {
      slot.classList.add('slot-dragover');
    }
  }

  private async handleClick(event: Event) {
    try {
      // HTMLElement„Åæ„Åü„ÅØSVGElement„ÅÆÂ†¥Âêà„Å´Âá¶ÁêÜ
      if (event.target instanceof HTMLElement || event.target instanceof SVGElement) {
        const target = event.target as Element;

        // „Çπ„É≠„ÉÉ„ÉàÂÆå‰∫Ü„Éú„Çø„É≥ÔºàSVG„ÇØ„É™„ÉÉ„ÇØ„Å´„ÇÇÂØæÂøúÔºâ
        const completeButtonElement = target.closest('.slot-complete-btn');
        if (completeButtonElement) {
          event.stopPropagation(); // „Ç§„Éô„É≥„Éà‰ºùÊê¨„ÇíÊ≠¢„ÇÅ„Çã
          const button = completeButtonElement as HTMLElement;
          const slotId = button.dataset.slotId;
          if (slotId) {
            await this.completeSlotAndTask(slotId);
          }
          return;
        }

        // „Çπ„É≠„ÉÉ„ÉàÂâäÈô§„Éú„Çø„É≥ÔºàSVG„ÇØ„É™„ÉÉ„ÇØ„Å´„ÇÇÂØæÂøúÔºâ
        const removeButtonElement = target.closest('.slot-remove-btn');
        if (removeButtonElement) {
          event.stopPropagation(); // „Ç§„Éô„É≥„Éà‰ºùÊê¨„ÇíÊ≠¢„ÇÅ„Çã
          const button = removeButtonElement as HTMLElement;
          const slotId = button.dataset.slotId;
          if (slotId) {
            await this.removeTaskFromSlot(slotId);
          }
          return;
        }

        // Á©∫„ÅÆ„Çπ„É≠„ÉÉ„Éà„ÇØ„É™„ÉÉ„ÇØÔºà„Çø„Çπ„ÇØÈÅ∏ÊäûÔºâ
        const slot = target.closest('.slot') as HTMLElement;
        if (slot && slot.classList.contains('slot-empty')) {
          const slotId = slot.dataset.slotId;
          if (slotId) {
            await this.showTaskSelectionModal(slotId);
          }
          return;
        }
      }
    } catch (error) {
      console.error('üö® Error in PomodoroSlots handleClick:', error);
    }
  }

  private async showTaskSelectionModal(slotId: string) {
    // Êó¢„Å´Âá¶ÁêÜ‰∏≠„ÅÆÂ†¥Âêà„ÅØ‰Ωï„ÇÇ„Åó„Å™„ÅÑ
    if (this.isProcessing) {
      console.log('Already processing, skipping...');
      return;
    }

    this.isProcessing = true;

    try {
      const backlogTasks = this.tasks.filter(task => task.status === TaskStatus.Backlog);

      if (backlogTasks.length === 0) {
        alert('Ââ≤„ÇäÂΩì„Å¶ÂèØËÉΩ„Å™„Çø„Çπ„ÇØ„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇÂÖà„Å´Backlog„Å´„Çø„Çπ„ÇØ„ÇíËøΩÂä†„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ');
        return;
      }

      // Á∞°ÊòìÁöÑ„Å™„Çø„Çπ„ÇØÈÅ∏Êäû„É¢„Éº„ÉÄ„É´
      const taskOptions = backlogTasks.map((task, index) =>
        `${index + 1}. ${task.name} (üçÖ${task.estimatePomodoros})`
      ).join('\n');

      let selectedIndex: string | null = null;
      let attempts = 0;
      const maxAttempts = 3;

      while (attempts < maxAttempts) {
        selectedIndex = prompt(
          `„Çø„Çπ„ÇØ„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ:\n\n${taskOptions}\n\nÁï™Âè∑„ÇíÂÖ•Âäõ (1-${backlogTasks.length}):`
        );

        // „Ç≠„É£„É≥„Çª„É´„Åï„Çå„ÅüÂ†¥ÂêàÔºànull „Åæ„Åü„ÅØ Á©∫ÊñáÂ≠óÂàó„Çí„Ç≠„É£„É≥„Çª„É´„Å®„Åó„Å¶Êâ±„ÅÜÔºâ
        if (selectedIndex === null) {
          console.log('„Çø„Çπ„ÇØÈÅ∏Êäû„Åå„Ç≠„É£„É≥„Çª„É´„Åï„Çå„Åæ„Åó„ÅüÔºànullÔºâ');
          return;
        }

        // Á©∫ÊñáÂ≠óÂàó„ÅÆÂ†¥Âêà„ÇÇ„Ç≠„É£„É≥„Çª„É´„Å®„Åó„Å¶Êâ±„ÅÜ
        if (selectedIndex.trim() === '') {
          console.log('„Çø„Çπ„ÇØÈÅ∏Êäû„Åå„Ç≠„É£„É≥„Çª„É´„Åï„Çå„Åæ„Åó„ÅüÔºàÁ©∫ÊñáÂ≠óÂàóÔºâ');
          return;
        }

        // ÊúâÂäπ„Å™Áï™Âè∑„ÅåÂÖ•Âäõ„Åï„Çå„ÅüÂ†¥Âêà
        const index = parseInt(selectedIndex.trim(), 10) - 1;
        console.log(`ÂÖ•ÂäõÂÄ§: "${selectedIndex}", Ëß£ÊûêÁµêÊûú: ${index + 1}, ÊúâÂäπÁØÑÂõ≤: 1-${backlogTasks.length}`);

        if (!isNaN(index) && index >= 0 && index < backlogTasks.length) {
          const selectedTask = backlogTasks[index];
          console.log(`ÈÅ∏Êäû„Åï„Çå„Åü„Çø„Çπ„ÇØ: ${selectedTask.name}`);
          await this.assignTaskToSlot(slotId, selectedTask.id);
          return;
        }

        // ÁÑ°Âäπ„Å™ÂÖ•Âäõ„ÅÆÂ†¥Âêà
        alert(`ÁÑ°Âäπ„Å™Áï™Âè∑„Åß„Åô„ÄÇ1„Åã„Çâ${backlogTasks.length}„ÅÆÈñì„ÅÆÊï∞Â≠ó„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ\nÂÖ•Âäõ„Åï„Çå„ÅüÂÄ§: "${selectedIndex}"`);
        attempts++;
      }

      // ÊúÄÂ§ßË©¶Ë°åÂõûÊï∞„Å´ÈÅî„Åó„ÅüÂ†¥Âêà
      alert('„Çø„Çπ„ÇØ„ÅÆÈÅ∏Êäû„Åå„Ç≠„É£„É≥„Çª„É´„Åï„Çå„Åæ„Åó„Åü„ÄÇ');
    } finally {
      // Âá¶ÁêÜÂÆå‰∫ÜÂæå„Å´„Éï„É©„Ç∞„Çí„É™„Çª„ÉÉ„Éà
      this.isProcessing = false;
    }
  }

  private async assignTaskToSlot(slotId: string, taskId: string) {
    const task = this.tasks.find(t => t.id === taskId);
    if (!task) return;

    try {
      await assignTaskToSlot(slotId, taskId, task.estimatePomodoros);
      await this.refreshSilent();

      if (this.onSlotUpdate) {
        this.onSlotUpdate();
      }
    } catch (error) {
      console.error('„Çø„Çπ„ÇØ„ÅÆÂâ≤„ÇäÂΩì„Å¶„Å´Â§±Êïó„Åó„Åæ„Åó„Åü:', error);
      alert('„Çø„Çπ„ÇØ„ÅÆÂâ≤„ÇäÂΩì„Å¶„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ');
    }
  }

  private async removeTaskFromSlot(slotId: string) {
    if (confirm('„Åì„ÅÆ„Çπ„É≠„ÉÉ„Éà„Åã„Çâ„Çø„Çπ„ÇØ„ÇíÂâäÈô§„Åó„Å¶„ÇÇ„Çà„Çç„Åó„ÅÑ„Åß„Åô„ÅãÔºü')) {
      try {
        await removeTaskFromSlot(slotId);
        await this.refreshSilent();

        if (this.onSlotUpdate) {
          this.onSlotUpdate();
        }
      } catch (error) {
        console.error('„Çø„Çπ„ÇØ„ÅÆÂâäÈô§„Å´Â§±Êïó„Åó„Åæ„Åó„Åü:', error);
        alert('„Çø„Çπ„ÇØ„ÅÆÂâäÈô§„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ');
      }
    }
  }

  public async refresh() {
    await this.loadData();
    this.render();
    if (this.onSlotUpdate) {
      this.onSlotUpdate();
    }
  }

  public async refreshSilent() {
    await this.loadData();
    this.render();
  }

  public getCurrentSlot(): PomodoroSlot | null {
    if (!this.dayPlan) return null;

    // Êú™ÂÆå‰∫Ü„ÅÆÊúÄÂàù„ÅÆ„Çπ„É≠„ÉÉ„Éà„ÇíËøî„Åô
    return this.dayPlan.slots.find(slot =>
      slot.taskId && !slot.completed
    ) || null;
  }

  public async completeCurrentSlot(): Promise<boolean> {
    const currentSlot = this.getCurrentSlot();
    if (!currentSlot) return false;

    try {
      const { completePomodoro } = await import('../utils/storage');
      await completePomodoro(currentSlot.id);
      await this.refresh();
      return true;
    } catch (error) {
      console.error('„Éù„É¢„Éâ„Éº„É≠„ÅÆÂÆå‰∫ÜÂá¶ÁêÜ„Å´Â§±Êïó„Åó„Åæ„Åó„Åü:', error);
      return false;
    }
  }

  private async completeSlotAndTask(slotId: string) {
    try {
      const { completePomodoro, updateTask } = await import('../utils/storage');

      // „Çπ„É≠„ÉÉ„Éà„ÇíÂÆå‰∫ÜÁä∂ÊÖã„Å´„Åô„Çã
      await completePomodoro(slotId);

      // Ë©≤ÂΩì„Åô„Çã„Çø„Çπ„ÇØ„ÇíÂèñÂæó
      const slot = this.dayPlan?.slots.find(s => s.id === slotId);
      if (!slot || !slot.taskId) return;

      const task = this.tasks.find(t => t.id === slot.taskId);
      if (!task) return;

      // „Åì„ÅÆ„Çø„Çπ„ÇØ„ÅÆÂÖ®„Çπ„É≠„ÉÉ„Éà„ÅåÂÆå‰∫Ü„Åó„Åü„Åã„ÉÅ„Çß„ÉÉ„ÇØ
      const taskSlots = this.dayPlan?.slots.filter(s => s.taskId === task.id) || [];
      const completedSlots = taskSlots.filter(s => s.completed).length + 1; // +1„ÅØ‰ªäÂÆå‰∫Ü„Åó„Åü„Çπ„É≠„ÉÉ„Éà

      // ÂÖ®„Çπ„É≠„ÉÉ„Éà„ÅåÂÆå‰∫Ü„Åó„ÅüÂ†¥Âêà„ÄÅ„Çø„Çπ„ÇØ„ÇíDone„Å´ÁßªÂãï
      if (completedSlots >= task.estimatePomodoros) {
        await updateTask(task.id, {
          status: TaskStatus.Done,
          completedAt: Date.now(),
          actualPomodoros: task.actualPomodoros + 1
        });
      } else {
        // „Åæ„Å†ÂÆå‰∫Ü„Åó„Å¶„ÅÑ„Å™„ÅÑÂ†¥Âêà„ÅØ„Éù„É¢„Éâ„Éº„É≠ÂÆüÁ∏æ„ÅÆ„ÅøÊõ¥Êñ∞
        await updateTask(task.id, {
          actualPomodoros: task.actualPomodoros + 1
        });
      }

      await this.refreshSilent();

      if (this.onSlotUpdate) {
        this.onSlotUpdate();
      }

    } catch (error) {
      console.error('„Çπ„É≠„ÉÉ„Éà„ÅÆÂÆå‰∫ÜÂá¶ÁêÜ„Å´Â§±Êïó„Åó„Åæ„Åó„Åü:', error);
      alert('„Çπ„É≠„ÉÉ„Éà„ÅÆÂÆå‰∫ÜÂá¶ÁêÜ„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ');
    }
  }

  private handleSlotDragStart(event: DragEvent) {
    try {
      // Êó¢„Å´Âá¶ÁêÜ‰∏≠„ÅÆÂ†¥Âêà„ÅØ‰Ωï„ÇÇ„Åó„Å™„ÅÑ
      if (this.isProcessing) {
        console.log('Drag start already processing, skipping');
        return;
      }

      if (event.target instanceof HTMLElement && event.target.hasAttribute('draggable')) {
        const taskId = event.target.dataset.taskId;
        const slotId = event.target.dataset.slotId;

        if (taskId && slotId && event.dataTransfer) {
          this.isProcessing = true; // Âá¶ÁêÜÈñãÂßã„Éï„É©„Ç∞

          event.dataTransfer.setData('text/plain', JSON.stringify({ taskId, slotId, source: 'slot' }));
          event.dataTransfer.effectAllowed = 'move';
          event.target.style.opacity = '0.5';
          event.target.classList.add('dragging');
          console.log('Slot drag started:', { taskId, slotId });

          // „Éâ„É©„ÉÉ„Ç∞ÁµÇ‰∫ÜÊôÇ„Å´„Éï„É©„Ç∞„Çí„É™„Çª„ÉÉ„Éà
          setTimeout(() => {
            this.isProcessing = false;
          }, 100);
        }
      }
    } catch (error) {
      console.error('Error in handleSlotDragStart:', error);
      this.isProcessing = false;
      this.resetDragStyles();
    }
  }

  private async handleSlotDrop(event: DragEvent) {
    event.preventDefault();

    try {
      console.log('=== Slot drop event triggered ===');
      console.log('Event target:', event.target);
      console.log('DataTransfer available:', !!event.dataTransfer);

      // ÂøÖ„Åö„Çπ„Çø„Ç§„É´„Çí„É™„Çª„ÉÉ„Éà
      this.resetDragStyles();

      if (event.target instanceof HTMLElement && event.dataTransfer) {
        const dropData = event.dataTransfer.getData('text/plain');
        console.log('Raw drop data:', `"${dropData}"`);
        console.log('Drop data length:', dropData.length);

        if (!dropData) {
          console.log('No drop data available, exiting');
          return;
        }

        try {
          const parsed = JSON.parse(dropData);
          console.log('Parsed drop data:', parsed);
          const { taskId: _taskId, slotId, source } = parsed;

          console.log('Extracted values:', { slotId, source });

          if (source === 'slot') {
            console.log('Processing slot-to-slot move');
            // „Çπ„É≠„ÉÉ„ÉàÈñì„Åß„ÅÆ‰∏¶„Å≥Êõø„Åà
            const targetSlot = event.target.closest('.slot[data-droppable="true"]') as HTMLElement;
            console.log('Target slot element:', targetSlot);

            if (targetSlot) {
              const targetSlotId = targetSlot.dataset.slotId;
              console.log('Target slot ID:', targetSlotId);
              console.log('Source slot ID:', slotId);

              if (targetSlotId && targetSlotId !== slotId) {
                console.log('Initiating slot swap');
                await this.reorderSlots(slotId, targetSlotId);
                console.log('Slot swap completed successfully');
              } else {
                console.log('No swap needed - same slot or missing target ID');
              }
            } else {
              console.log('No valid target slot found');
            }
          } else {
            console.log('Processing kanban-to-slot move');
            // „Ç´„É≥„Éê„É≥„Åã„Çâ„ÅÆ„Éâ„É≠„ÉÉ„ÉóÂá¶ÁêÜ
            const targetSlot = event.target.closest('.slot[data-droppable="true"]') as HTMLElement;
            if (targetSlot && targetSlot.classList.contains('slot-empty')) {
              const targetSlotId = targetSlot.dataset.slotId;
              if (targetSlotId) {
                await this.assignTaskToSlot(targetSlotId, dropData); // dropData„ÅåtaskId
              }
            }
          }
        } catch (parseError) {
          console.log('JSON parsing failed:', parseError);
          console.log('Processing as kanban-to-slot move');
          // JSON parsing failed, treat as kanban task drop
          const targetSlot = event.target.closest('.slot[data-droppable="true"]') as HTMLElement;
          if (targetSlot && targetSlot.classList.contains('slot-empty')) {
            const targetSlotId = targetSlot.dataset.slotId;
            if (targetSlotId && dropData) {
              await this.assignTaskToSlot(targetSlotId, dropData); // dropData„ÅåtaskId
            }
          }
        }
      } else {
        console.log('Invalid event target or no dataTransfer');
      }
    } catch (error) {
      console.error('Error in handleSlotDrop:', error);
      alert('„Çπ„É≠„ÉÉ„Éà„ÅÆÁßªÂãï„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ');
    } finally {
      // Á¢∫ÂÆü„Å´„Çπ„Çø„Ç§„É´„Çí„É™„Çª„ÉÉ„Éà
      this.resetDragStyles();
      console.log('=== Slot drop processing completed ===');
    }
  }

  private resetDragStyles() {
    // „Éè„Ç§„É©„Ç§„Éà„ÇíÂâäÈô§
    this.container.querySelectorAll('.slot-dragover').forEach(el => {
      el.classList.remove('slot-dragover');
    });

    // „Éâ„É©„ÉÉ„Ç∞‰∏≠„ÅÆ„Çπ„Çø„Ç§„É´„Çí„É™„Çª„ÉÉ„Éà
    this.container.querySelectorAll('[draggable="true"]').forEach(el => {
      const element = el as HTMLElement;
      element.style.opacity = '1';
      element.classList.remove('dragging');
    });
  }

  private async reorderSlots(sourceSlotId: string, targetSlotId: string) {
    try {
      console.log('Starting slot reorder:', { sourceSlotId, targetSlotId });

      // „ÇΩ„Éº„Çπ„Å®„Çø„Éº„Ç≤„ÉÉ„Éà„ÅåÂêå„ÅòÂ†¥Âêà„ÅØ‰Ωï„ÇÇ„Åó„Å™„ÅÑ
      if (sourceSlotId === targetSlotId) {
        console.log('Source and target are the same, skipping');
        return;
      }

      const { swapSlotAssignments } = await import('../utils/storage');
      await swapSlotAssignments(sourceSlotId, targetSlotId);

      console.log('Storage swap completed, refreshing UI');
      await this.refreshSilent();

      if (this.onSlotUpdate) {
        this.onSlotUpdate();
      }

      console.log('Slot reorder completed successfully');
    } catch (error) {
      console.error('„Çπ„É≠„ÉÉ„Éà„ÅÆ‰∏¶„Å≥Êõø„Åà„Å´Â§±Êïó„Åó„Åæ„Åó„Åü:', error);
      console.error('Error details:', {
        sourceSlotId,
        targetSlotId,
        error: (error as Error).message,
        stack: (error as Error).stack
      });
      alert('„Çπ„É≠„ÉÉ„Éà„ÅÆ‰∏¶„Å≥Êõø„Åà„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ');
    }
  }
}
